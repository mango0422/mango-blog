// D:\vercel\mango-blog\eslint.config.mjs
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


// D:\vercel\mango-blog\global.d.ts
// global.d.ts

declare module "nextra/pages" {
  import type { ComponentType, ReactElement } from "react";
  import type { Heading as MdastHeading } from "mdast";
  import type { Metadata } from "next";

  /** Nextra가 사용하는 목차(Heading) 타입 */
  export type Heading = {
    // H1은 제외
    depth: Exclude<MdastHeading["depth"], 1>;
    value: string | ReactElement;
    id: string;
  };

  export type ReadingTime = {
    text: string;
    minutes: number;
    time: number;
    words: number;
  };

  /** Nextra의 $NextraMetadata */
  export type NextraMetadata = Omit<Metadata, "title"> & {
    title: string;
    filePath: string;
    timestamp?: number;
    readingTime?: ReadingTime;
  };

  /** Nextra의 EvaluateResult (any 제거 버전) */
  export interface EvaluateResult {
    /** 렌더링할 MDX 컴포넌트 */
    default: ComponentType<Record<string, unknown>>;
    /** 목차 리스트 */
    toc: Heading[];
    /** front matter/metadata */
    metadata: NextraMetadata;
    /** 원본 MDX 소스 */
    sourceCode: string;
  }

  /**
   * content 디렉터리에서 MDX/Markdown 페이지를 불러옴
   */
  export function importPage(
    pathSegments?: string[],
    lang?: string
  ): Promise<EvaluateResult>;

  /**
   * Next.js generateStaticParams용 헬퍼
   */
  export function generateStaticParamsFor(
    segmentKey: string,
    localeSegmentKey?: string
  ): () => Promise<Array<Record<string, string | string[]>>>;
}

// CSS import용 선언
declare module "*.css";


// D:\vercel\mango-blog\next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// D:\vercel\mango-blog\next.config.mjs
// next.config.mjs
import nextra from "nextra";

const withNextra = nextra({
  // 검색 엔진(Pagefind) 설정 – 코드블록은 검색 제외 예시
  // 필요 없으면 search: true 로 두거나 아예 옵션 제거해도 됨
  search: { codeblocks: false }, // :contentReference[oaicite:3]{index=3}
});

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // Next 15.3+ 에서는 turbopack.resolveAlias 사용 :contentReference[oaicite:4]{index=4}
  turbopack: {
    resolveAlias: {
      // 루트에 둘 mdx-components.tsx 경로
      "next-mdx-import-source-file": "./src/mdx-components.tsx",
    },
  },
};

export default withNextra(nextConfig);


// D:\vercel\mango-blog\package.json
{
  "name": "mango-blog",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "postbuild": "pagefind --site .next/server/app --output-path public/_pagefind",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@mdx-js/loader": "3.1.1",
    "@mdx-js/react": "3.1.1",
    "@next/mdx": "16.0.3",
    "@types/mdx": "2.0.13",
    "next": "16.0.3",
    "next-themes": "0.4.6",
    "nextra": "4.6.0",
    "nextra-theme-blog": "4.6.0",
    "nextra-theme-docs": "4.6.0",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "shiki": "3.15.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "4.1.17",
    "@types/mdast": "^4.0.4",
    "@types/node": "20.19.25",
    "@types/react": "19.2.6",
    "@types/react-dom": "19.2.3",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "9.39.1",
    "eslint-config-next": "16.0.3",
    "pagefind": "1.4.0",
    "tailwindcss": "4.1.17",
    "typescript": "5.9.3"
  },
  "browserslist": [
    "defaults",
    "not IE 11",
    "not dead"
  ]
}


// D:\vercel\mango-blog\postcss.config.mjs
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


// D:\vercel\mango-blog\tsconfig.json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "global.d.ts",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts",
    "next.config.mjs"
  ],
  "exclude": ["node_modules"]
}


// D:\vercel\mango-blog\src\mdx-components.tsx
// src/mdx-components.tsx
import type { MDXComponents } from "nextra/mdx-components";
import { useMDXComponents as getThemeComponents } from "nextra-theme-docs";
import { Steps, Tabs, FileTree } from "nextra/components";
import { Callout } from "@/components/mdx/Callout";
import { Solution } from "@/components/mdx/Solution";
import { Complexity } from "@/components/mdx/Complexity";
import { JavaDoc } from "@/components/mdx/JavaDoc";

const themeComponents = getThemeComponents();

export function useMDXComponents(
  components: MDXComponents = {} as MDXComponents
): MDXComponents {
  return {
    ...themeComponents,

    Callout,
    Steps,
    Tabs,
    FileTree,
    Solution,
    Complexity,
    JavaDoc,

    ...components,
  };
}


// D:\vercel\mango-blog\src\app\fonts.ts
// src/app/fonts.ts
import localFont from "next/font/local";

// 제목용(귀엽게) + 한글/영문 모두 CookieRun
export const cuteFont = localFont({
  src: [
    {
      path: "../fonts/CookieRun-Regular.woff2",
      weight: "400",
      style: "normal",
    },
    {
      path: "../fonts/CookieRun-Bold.woff2",
      weight: "700",
      style: "normal",
    },
    {
      path: "../fonts/CookieRun-Black.woff2",
      weight: "900",
      style: "normal",
    },
  ],
  variable: "--font-cute", // ✅ globals.css에서 쓰는 이름과 맞춤
  display: "swap",
});

// 본문용도 동일 폰트로(원하면 나중에 다른 폰트로 갈아껴도 됨)
export const sansFont = localFont({
  src: [
    {
      path: "../fonts/CookieRun-Regular.woff2",
      weight: "400",
      style: "normal",
    },
    {
      path: "../fonts/CookieRun-Bold.woff2",
      weight: "700",
      style: "normal",
    },
    {
      path: "../fonts/CookieRun-Black.woff2",
      weight: "900",
      style: "normal",
    },
  ],
  variable: "--font-sans", // ✅ globals.css에서 쓰는 이름과 맞춤
  display: "swap",
});


// D:\vercel\mango-blog\src\app\globals.css
/* app/globals.css */
@import "tailwindcss";
@import "nextra-theme-docs/style.css";
/* @import "nextra-theme-blog/style.css"; */

/* 1. Tailwind v4 테마 정의 (망고 블로그) */
@theme {
  /* 폰트 변수 (layout.tsx에서 주입됨) */
  --font-cute: var(--font-cute);
  --font-sans: var(--font-sans);

  /* 망고 컬러 팔레트 */
  --color-mango-bg: oklch(0.18 0.03 260);
  --color-mango-card: oklch(0.22 0.03 260);
  --color-mango-accent: oklch(0.78 0.16 280);
}

/* 2. Nextra CSS 변수 오버라이딩 (디자인 장악) */
:root {
  --nextra-primary-hue: 280deg;
  --nextra-primary-saturation: 80%;

  /* 폰트 적용: Nextra 기본 폰트도 CookieRun으로 */
  --nextra-font-sans: var(--font-sans);

  --nextra-bg: #ffffff;
}

/* 전체 페이지 기본 배경 */
html,
body {
  background-color: var(--color-mango-bg);
}

/* 다크모드 강제 색상 */
.dark {
  --nextra-bg: var(--color-mango-bg) !important;
  --nextra-sidebar-bg: var(--color-mango-bg) !important;
}

/* 다크모드 수정: 텍스트 가독성을 위해 밝기를 올림 */
.dark body {
  /* 기존 0.9 -> 0.94 로 상향 조정 (더 밝게) */
  color: oklch(0.94 0.02 260);
}

/* 보조 텍스트들도 명도 대비를 높입니다 */
.dark .nx-text-gray-400,
.dark .nx-text-slate-400,
.dark .nx-text-neutral-400 {
  /* 기존 0.8 -> 0.85 */
  color: oklch(0.85 0.03 260) !important;
}

.dark .nx-text-gray-500,
.dark .nx-text-slate-500,
.dark .nx-text-neutral-500 {
  /* 기존 0.86 -> 0.90 */
  color: oklch(0.9 0.03 260) !important;
}

/* 사이드바/네비게이션 항목도 더 선명하게 */
.dark .nextra-sidebar .nx-text-sm,
.dark .nextra-sidebar .nx-text-xs {
  color: oklch(0.9 0.02 260) !important;
}

/* 푸터처럼 '회색 설명글'이 많은 곳도 전체 상향 */
.dark footer,
.dark .nextra-footer {
  color: oklch(0.84 0.02 260);
}

/* 다크모드일 때 사이드바/메뉴 텍스트 더 밝게 */
.dark .nextra-sidebar-item,
.dark .nextra-sidebar-item a,
.dark .nextra-menu,
.dark .nextra-menu a {
  color: oklch(0.85 0.03 280) !important; /* 밝은 보라빛 회색 */
}

/* 활성 메뉴/호버 시는 더 밝게 */
.dark .nextra-sidebar-item a:hover,
.dark .nextra-sidebar-item[data-active="true"] a,
.dark .nextra-sidebar-link:is([data-active="true"], :hover) {
  color: oklch(0.97 0.02 280) !important;
}

/* 섹션 제목(예: "Posts", "Til")도 같이 밝게 */
.dark .nextra-sidebar-title,
.dark .nextra-menu-header {
  color: oklch(0.8 0.03 280) !important;
}

.dark main,
.dark .nextra-content,
.dark .nextra-layout {
  background-color: transparent !important;
  box-shadow: none !important;
}

/* 제목 폰트 교체 (귀여운 폰트) */
h1,
h2,
h3,
h4,
h5,
h6,
.nextra-search-input,
.nextra-nav-link,
.nextra-sidebar-item {
  font-family: var(--font-cute) !important;
  letter-spacing: 0.03em;
}

/* 본문 폰트 (가독성) */
body {
  font-family: var(--font-sans);
}

/* 데스크톱: 왼쪽 사이드바 오버레이/패널 */
@media (min-width: 1025px) {
  .nextra-sidebar-container {
    background-color: rgba(0, 0, 0, 0.55);
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
  }

  .nextra-sidebar {
    background-color: var(--color-mango-bg);
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
  }
}

/* 모바일: 햄버거 메뉴 오버레이/패널 */
@media (max-width: 1024px) {
  .nextra-mobile-nav {
    background-color: rgba(0, 0, 0, 0.55) !important;
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
  }

  .nextra-mobile-nav > div,
  .nextra-mobile-nav > ul {
    background-color: var(--color-mango-bg);
    border-radius: 0.75rem;
    margin: 0.75rem;
  }
}


// D:\vercel\mango-blog\src\app\layout.tsx
import "./globals.css";
import type { ReactNode } from "react";
import { Layout, Navbar, Footer } from "nextra-theme-docs";
import { getPageMap } from "nextra/page-map";
import { siteConfig } from "@/config/site";
import { cuteFont, sansFont } from "./fonts";
import { Head } from "nextra/components";
import { ThemeSwitch } from "@/components/ThemeSwitch";

export const metadata = {
  title: siteConfig.name,
  description: siteConfig.description,
};

export default async function RootLayout({
  children,
}: {
  children: ReactNode;
}) {
  const pageMap = await getPageMap();

  const navbar = (
    <Navbar
      logo={
        <span className="font-semibold text-lg tracking-tight flex items-center gap-1">
          <span>🍋</span>
          <span>Mango</span>
          <span className="hidden sm:inline text-primary-500">Blog</span>
        </span>
      }
      projectLink={siteConfig.github}
    >
      {/* ✅ Navbar 우측에 테마 스위치 배치 */}
      <ThemeSwitch />
    </Navbar>
  );

  const footer = (
    <Footer>
      <div className="text-sm text-gray-500 font-cute">
        © {new Date().getFullYear()} {siteConfig.name}. All rights reserved.
      </div>
    </Footer>
  );

  return (
    <html
      lang="ko"
      suppressHydrationWarning
      className={`${cuteFont.variable} ${sansFont.variable}`}
      dir="ltr"
    >
      <Head />
      <body>
        <Layout
          pageMap={pageMap}
          sidebar={{
            autoCollapse: true,
            defaultMenuCollapseLevel: 1,
            toggleButton: true,
          }}
          docsRepositoryBase={siteConfig.github}
          darkMode={false}
          navbar={navbar}
          footer={footer}
          toc={{
            title: "On This Page",
          }}
        >
          {children}
        </Layout>
      </body>
    </html>
  );
}


// D:\vercel\mango-blog\src\app\not-found.tsx
// app/not-found.tsx
import Link from "next/link";
import { NotFoundPage } from "nextra-theme-docs";

export default function NotFound() {
  return (
    <NotFoundPage content="GitHub 이슈로 신고하기" labels="broken-link">
      <h1>404</h1>
      <h2>페이지를 찾을 수 없어요 🍪</h2>
      <p>아마도 제가 먹어버린 것 같습니다.</p>
      <Link
        href="/"
        className="mt-8 rounded-full bg-mango-accent px-6 py-3 text-white font-cute hover:opacity-80 transition"
      >
        홈으로 돌아가기
      </Link>
    </NotFoundPage>
  );
}


// D:\vercel\mango-blog\src\app\robots.ts
import { MetadataRoute } from "next";
import { siteConfig } from "@/config/site";

export default function robots(): MetadataRoute.Robots {
  return {
    rules: {
      userAgent: "*",
      allow: "/",
      // 필요한 경우 관리자 페이지 등은 disallow 처리
      // disallow: '/private/',
    },
    sitemap: `${siteConfig.url}/sitemap.xml`, // Nextra가 자동으로 sitemap을 생성한다면 해당 경로 지정
  };
}


// D:\vercel\mango-blog\src\app\posts\get-posts.ts
// src/app/posts/get-posts.ts
export * from "@/lib/blog";


// D:\vercel\mango-blog\src\app\rss.xml\route.ts
// app/rss.xml/route.ts
import { NextResponse } from "next/server";
import { getBlogPosts } from "../posts/get-posts";
import { siteConfig } from "@/config/site";

const SITE_URL = siteConfig.url; // 실제 도메인으로 수정

export async function GET() {
  const posts = await getBlogPosts();

  const items = posts
    .map(
      (post) => `
      <item>
        <title><![CDATA[${post.frontMatter.title}]]></title>
        <link>${SITE_URL}${post.route}</link>
        <pubDate>${new Date(post.frontMatter.date).toUTCString()}</pubDate>
        <description><![CDATA[${
          post.frontMatter.description ?? ""
        }]]></description>
      </item>`
    )
    .join("\n");

  const xml = `<?xml version="1.0" encoding="UTF-8" ?>
  <rss version="2.0">
    <channel>
      <title>{siteConfig.name}</title>
      <link>${SITE_URL}</link>
      <description>{siteConfig.description} RSS</description>
      ${items}
    </channel>
  </rss>`;

  return new NextResponse(xml, {
    status: 200,
    headers: {
      "Content-Type": "application/rss+xml; charset=utf-8",
    },
  });
}


// D:\vercel\mango-blog\src\app\[[...mdxPath]]\page.tsx
// src/app/[[...mdxPath]]/page.tsx
import { generateStaticParamsFor, importPage } from "nextra/pages";
import type { Heading, NextraMetadata } from "nextra/pages";
import type { ReactNode, ComponentType } from "react";
import { useMDXComponents as getMDXComponents } from "../../mdx-components";

export const generateStaticParams = generateStaticParamsFor("mdxPath");

type MdxParams = {
  mdxPath?: string[];
};

type PageProps = {
  params: Promise<MdxParams>;
};

export async function generateMetadata(props: PageProps) {
  const params = await props.params;
  const { metadata } = await importPage(params.mdxPath ?? []);
  return metadata;
}

type WrapperProps = {
  children?: ReactNode;
  toc?: Heading[]; // global.d.ts에서 가져온 타입
  metadata?: NextraMetadata;
  sourceCode?: string;
};

// 1) 컴포넌트 한 번 받아오고
const components = getMDXComponents();

const Wrapper: ComponentType<WrapperProps> =
  (components.wrapper as ComponentType<WrapperProps>) ??
  (({ children }) => <>{children}</>);

export default async function Page(props: PageProps) {
  const params = await props.params;
  const {
    default: MDXContent,
    toc,
    metadata,
    sourceCode,
  } = await importPage(params.mdxPath ?? []);

  return (
    <Wrapper toc={toc} metadata={metadata} sourceCode={sourceCode}>
      <MDXContent {...props} params={params} />
    </Wrapper>
  );
}


// D:\vercel\mango-blog\src\components\ThemeSwitch.tsx
"use client";

import { useTheme } from "next-themes";
import { useEffect, useState, useRef, useSyncExternalStore } from "react";

type ThemeSwitchProps = {
  className?: string;
};

export function ThemeSwitch({ className = "" }: ThemeSwitchProps) {
  const { theme, setTheme, resolvedTheme } = useTheme();
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // ✅ Hydration Mismatch 방지 로직
  // 이 useEffect는 클라이언트에서만 실행되므로, 이 시점 이후에만 실제 아이콘을 그립니다.
  const mounted = useSyncExternalStore(
    emptySubscribe,
    () => true, // Client-side value
    () => false // Server-side value
  );

  // 외부 클릭 시 메뉴 닫기
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // ✅ 마운트 전(서버 사이드)에는 스켈레톤(빈 원형)을 보여줘서 HTML 불일치를 막습니다.
  if (!mounted) {
    return (
      <div
        className={`w-9 h-9 rounded-full bg-gray-100 dark:bg-gray-800 border border-transparent ${className}`}
      />
    );
  }

  // 현재 테마 아이콘 결정
  const CurrentIcon =
    theme === "system"
      ? SystemIcon
      : resolvedTheme === "dark"
      ? MoonIcon
      : SunIcon;

  return (
    <div className={`relative ${className}`} ref={menuRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        aria-label="테마 변경"
        className={`
          flex items-center justify-center w-9 h-9 rounded-full transition-all duration-200
          border border-transparent hover:border-gray-300 dark:hover:border-gray-600
          bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700
          ${
            isOpen
              ? "ring-2 ring-mango-accent ring-opacity-50 bg-gray-200 dark:bg-gray-700"
              : ""
          }
        `}
      >
        <CurrentIcon className="w-4 h-4 text-gray-600 dark:text-gray-300" />
      </button>

      {isOpen && (
        <div className="absolute right-0 top-full mt-2 w-36 py-1 rounded-xl border border-gray-200 dark:border-gray-700 bg-white/90 dark:bg-gray-900/90 backdrop-blur-md shadow-xl z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-100">
          <div className="px-3 py-2 text-xs font-semibold text-gray-400 uppercase tracking-wider">
            Theme
          </div>

          {themes.map(({ value, label, Icon }) => (
            <button
              key={value}
              onClick={() => {
                setTheme(value);
                setIsOpen(false);
              }}
              className={`
                w-full px-4 py-2 text-sm flex items-center gap-3 transition-colors
                ${
                  theme === value
                    ? "text-mango-accent bg-mango-accent/10 font-medium"
                    : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800"
                }
              `}
            >
              <Icon
                className={`w-4 h-4 ${
                  theme === value ? "text-mango-accent" : "text-gray-500"
                }`}
              />
              {label}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
const emptySubscribe = () => () => {};
// --- 아이콘 컴포넌트 (SVG) ---
const themes = [
  { value: "light", label: "Light", Icon: SunIcon },
  { value: "dark", label: "Dark", Icon: MoonIcon },
  { value: "system", label: "System", Icon: SystemIcon },
];

function SunIcon({ className }: { className?: string }) {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <circle cx="12" cy="12" r="5" />
      <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" />
    </svg>
  );
}

function MoonIcon({ className }: { className?: string }) {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
    </svg>
  );
}

function SystemIcon({ className }: { className?: string }) {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
      <line x1="8" y1="21" x2="16" y2="21" />
      <line x1="12" y1="17" x2="12" y2="21" />
    </svg>
  );
}


// D:\vercel\mango-blog\src\components\mdx\Callout.tsx
// src/components/mdx/Callout.tsx
type CalloutProps = {
  type?: "info" | "warning" | "success";
  title?: string;
  children: React.ReactNode;
};

const colorMap = {
  info: "border-sky-500/60 bg-sky-500/5",
  warning: "border-amber-500/60 bg-amber-500/5",
  success: "border-emerald-500/60 bg-emerald-500/5",
} satisfies Record<NonNullable<CalloutProps["type"]>, string>;

export function Callout({ type = "info", title, children }: CalloutProps) {
  const color = colorMap[type];

  return (
    <div className={`my-4 rounded-2xl border px-4 py-3 text-sm ${color}`}>
      {title && <div className="mb-1 font-semibold">{title}</div>}
      <div className="leading-relaxed">{children}</div>
    </div>
  );
}


// D:\vercel\mango-blog\src\components\mdx\Complexity.tsx
// type: good(초록), bad(빨강), average(노랑)
export function Complexity({
  type = "average",
  children,
}: {
  type?: "good" | "bad" | "average";
  children: React.ReactNode;
}) {
  const colors = {
    good: "bg-green-100 text-green-800 border-green-200 dark:bg-green-900/30 dark:text-green-300",
    average:
      "bg-yellow-100 text-yellow-800 border-yellow-200 dark:bg-yellow-900/30 dark:text-yellow-300",
    bad: "bg-red-100 text-red-800 border-red-200 dark:bg-red-900/30 dark:text-red-300",
  };

  return (
    <span
      className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border ${colors[type]} font-mono mx-1`}
    >
      {children}
    </span>
  );
}


// D:\vercel\mango-blog\src\components\mdx\JavaDoc.tsx
export function JavaDoc({
  name,
  className,
}: {
  name?: string;
  className: string;
}) {
  // Java 17 문서 기준 URL 생성
  const baseUrl = "https://docs.oracle.com/en/java/javase/17/docs/api/";
  const path = className.replace(/\./g, "/") + ".html";

  return (
    <a
      href={`${baseUrl}${path}`}
      target="_blank"
      rel="noreferrer"
      className="text-blue-600 dark:text-blue-400 hover:underline decoration-wavy underline-offset-4"
    >
      <code className="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded text-sm">
        {name || className.split(".").pop()}
      </code>
    </a>
  );
}


// D:\vercel\mango-blog\src\components\mdx\Solution.tsx
"use client";
import { useState } from "react";

export function Solution({
  title = "해답 보기",
  children,
}: {
  title?: string;
  children: React.ReactNode;
}) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="my-4 border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full px-4 py-3 text-left bg-gray-50 dark:bg-gray-800 font-medium flex justify-between items-center hover:bg-gray-100 dark:hover:bg-gray-700 transition"
      >
        <span>🧩 {title}</span>
        <span>{isOpen ? "접기 ▲" : "펼치기 ▼"}</span>
      </button>
      {isOpen && (
        <div className="p-4 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700 animate-in slide-in-from-top-2 duration-200">
          {children}
        </div>
      )}
    </div>
  );
}


// D:\vercel\mango-blog\src\config\site.ts
// src/config/site.ts
export const siteConfig = {
  name: "Mango Blog",
  description: "개발자 망고의 기술 블로그 & 문서 허브",
  url: process.env.NEXT_PUBLIC_SITE_URL ?? "http://localhost:3000",
  github: "https://github.com/mango0422/mango-blog",
};


// D:\vercel\mango-blog\src\content\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  index: { title: "홈", display: "hidden" },
  java: { title: "Java", type: "page" },
  springboot: { title: "SpringBoot", type: "page" },
  til: { title: "TIL", type: "page" },
};

export default meta;


// D:\vercel\mango-blog\src\content\java\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "ch01-interfaces": "1. 인터페이스",
  "ch02-analysis": "2. 알고리즘 분석",
  "ch03-arraylist": "3. ArrayList 클래스",
  "ch04-linkedlist": "4. LinkedList 클래스",
  "ch05-doubly-linked": "5. 이중 연결 리스트",
  "ch06-tree-traversal": "6. 트리 순회",
  "ch07-philosophy": "7. 철학으로 가는 길",
  "ch08-indexer": "8. 인덱서",
  "ch09-map": "9. Map 인터페이스",
  "ch10-hashing": "10. 해싱",
  "ch11-hashmap": "11. HashMap 클래스",
  "ch12-treemap": "12. TreeMap 클래스",
  "ch13-bst": "13. 이진 탐색 트리",
  "ch14-persistence": "14. 영속성 (Redis)",
  "ch15-crawling": "15. 위키피디아 크롤링",
  "ch16-boolean-search": "16. 불리언 검색",
  "ch17-sorting": "17. 정렬",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch01-interfaces\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-list-types": "1.1 리스트가 두 종류인 이유",
  "2-java-interface": "1.2 자바 interface",
  "3-list-interface": "1.3 List interface",
  "4-lab-01": "1.4 실습 1",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch02-analysis\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-selection-sort": "2.1 선택 정렬",
  "2-big-o": "2.2 빅오 표기법",
  "3-lab-02": "2.3 실습 2",
};


export default meta;

// D:\vercel\mango-blog\src\content\java\ch03-arraylist\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-classify-myarraylist": "3.1 MyArrayList 메서드 분류하기",
  "2-classify-add": "3.2 add 메서드 분류하기",
  "3-problem-size": "3.3 문제 크기",
  "4-linked-structures": "3.4 연결 자료구조",
  "5-lab-03": "3.5 실습 3",
  "6-gc": "3.6 가비지 컬렉션",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch04-linkedlist\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-classify-mylinkedlist": "4.1 MyLinkedList 메서드 분류하기",
  "2-compare-lists": "4.2 MyArrayList와 MyLinkedList 비교하기",
  "3-profile": "4.3 프로파일",
  "4-interpret-results": "4.4 결과 해석하기",
  "5-lab-04": "4.5 실습 4",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch05-doubly-linked\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-profile-results": "5.1 성능 프로파일 결과",
  "2-profile-linkedlist": "5.2 LinkedList 메서드 프로파일하기",
  "3-add-to-end": "5.3 LinkedList 끝에 더하기",
  "4-doubly-linked-list": "5.4 이중 연결 리스트",
  "5-choose-structure": "5.5 자료구조 선택하기",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch06-tree-traversal\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-search-engine": "6.1 검색 엔진",
  "2-parsing-html": "6.2 HTML 파싱하기",
  "3-using-jsoup": "6.3 jsoup 사용하기",
  "4-iterating-dom": "6.4 DOM 트리 반복하기",
  "5-dfs": "6.5 깊이 우선 탐색",
  "6-stacks": "6.6 스택",
  "7-iterative-dfs": "6.7 반복적 DFS",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch07-philosophy\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-getting-started": "7.1 시작하기",
  "2-iterable-iterator": "7.2 Iterable과 Iterator",
  "3-wikifetcher": "7.3 WikiFetcher",
  "4-lab-05": "7.4 실습 5",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch08-indexer\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-choose-structure": "8.1 자료구조 선택",
  "2-term-counter": "8.2 TermCounter",
  "3-lab-06": "8.3 실습 6",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch09-map\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-mylinearmap": "9.1 MyLinearMap 구현하기",
  "2-lab-07": "9.2 실습 7",
  "3-analyze-mylinearmap": "9.3 MyLinearMap 분석하기",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch10-hashing\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-hashing": "10.1 해싱",
  "2-how-hashing-works": "10.2 해싱의 동작 방식",
  "3-hashing-mutation": "10.3 해싱과 변형",
  "4-lab-08": "10.4 실습 8",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch11-hashmap\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-lab-09": "11.1 실습 9",
  "2-analyze-myhashmap": "11.2 MyHashMap 분석하기",
  "3-tradeoffs": "11.3 트레이드오프",
  "4-profile-myhashmap": "11.4 MyHashMap 프로파일링",
  "5-fix-myhashmap": "11.5 MyHashMap 클래스 고치기",
  "6-uml": "11.6 UML 클래스 다이어그램",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch12-treemap\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-hashing-problems": "12.1 해싱의 문제점",
  "2-bst": "12.2 이진 탐색 트리",
  "3-lab-10": "12.3 실습 10",
  "4-implement-treemap": "12.4 TreeMap 구현하기",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch13-bst\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-simple-mytreemap": "13.1 단순한 MyTreeMap 클래스",
  "2-search-values": "13.2 값 탐색하기",
  "3-implement-put": "13.3 put 메서드 구현하기",
  "4-in-order": "13.4 중위 순회",
  "5-log-time": "13.5 로그 시간 메서드",
  "6-self-balancing": "13.6 자가 균형 트리",
  "7-lab-extra": "13.7 추가 실습",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch14-persistence\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-redis": "14.1 레디스",
  "2-redis-cs": "14.2 레디스 클라이언트와 서버",
  "3-redis-index": "14.3 레디스 기반 인덱스 만들기",
  "4-redis-types": "14.4 레디스 데이터 타입",
  "5-lab-11": "14.5 실습 11",
  "6-suggestions": "14.6 추가 제안",
  "7-design-hints": "14.7 설계 힌트",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch15-crawling\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-redis-indexer": "15.1 레디스 기반의 인덱서",
  "2-lookup-perf": "15.2 조회 성능 분석",
  "3-indexing-perf": "15.3 인덱싱 성능 분석",
  "4-graph-traversal": "15.4 그래프 순회",
  "5-lab-12": "15.5 실습 12",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch16-boolean-search\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-crawler-solution": "16.1 크롤러 해답",
  "2-info-retrieval": "16.2 정보 검색",
  "3-boolean-search": "16.3 불리언 검색",
  "4-lab-13": "16.4 실습 13",
  "5-comparable": "16.5 Comparable과 Comparator",
  "6-extensions": "16.6 확장",
};

export default meta;


// D:\vercel\mango-blog\src\content\java\ch17-sorting\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-insertion-sort": "17.1 삽입 정렬",
  "2-lab-14": "17.2 실습 14",
  "3-merge-sort": "17.3 병합 정렬 분석",
  "4-radix-sort": "17.4 기수 정렬",
  "5-heap-sort": "17.5 힙 정렬",
  "6-bounded-heap": "17.6 제한된 힙 정렬",
  "7-space-complexity": "17.7 공간 복잡도",
};

export default meta;


// D:\vercel\mango-blog\src\content\springboot\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "01-spring-core": "1. 스프링부트 기초",
  "02-spring-boot-jpa": "2. 스프링부트 JPA",
};

export default meta;


// D:\vercel\mango-blog\src\content\springboot\01-spring-core\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-spring-mvc-flow": "1. Spring MVC 전체 흐름",
  "2-ioc-di-basics": "2. IoC/DI 핵심 개념",
  "3-bean-lifecycle": "3. Bean Lifecycle",
  "4-rest-api-design": "4. REST API 기본 설계",
  "5-exception-handling": "5. 예외 처리(@ControllerAdvice)",
};

export default meta;


// D:\vercel\mango-blog\src\content\springboot\02-spring-boot-jpa\_meta.ts
import type { MetaRecord } from "nextra";

const meta: MetaRecord = {
  "1-autoconfiguration": "1. Spring Boot AutoConfiguration",
  "2-jpa-persistence-context": "2. JPA 기본 동작(영속성 컨텍스트)",
  "3-transaction-propagation-isolation": "3. 트랜잭션 전파/격리",
};

export default meta;


// D:\vercel\mango-blog\src\lib\blog.ts
// src/lib/blog.ts
import { getDirectoryPages } from "./nextra-pages";

export type BlogFrontMatter = {
  title: string;
  date: string;
  tags?: string[];
  description?: string;
};

export type BlogPost = {
  name: string;
  route: string;
  frontMatter: BlogFrontMatter;
};

export function isBlogPost(value: unknown): value is BlogPost {
  if (!value || typeof value !== "object") return false;

  const v = value as {
    route?: unknown;
    frontMatter?: Record<string, unknown>;
    name?: unknown;
  };

  return (
    typeof v.route === "string" &&
    typeof v.name === "string" &&
    v.frontMatter != null &&
    typeof v.frontMatter.title === "string" &&
    typeof v.frontMatter.date === "string"
  );
}

export async function getBlogPosts(baseRoute = "/posts"): Promise<BlogPost[]> {
  const directories = await getDirectoryPages(baseRoute);
  const typed = (directories as unknown[]).filter(isBlogPost);

  return typed
    .filter((post) => post.name !== "index")
    .sort(
      (a, b) =>
        new Date(b.frontMatter.date).getTime() -
        new Date(a.frontMatter.date).getTime()
    );
}

export async function getBlogTags(): Promise<string[]> {
  const posts = await getBlogPosts();
  return posts.flatMap((post) => post.frontMatter.tags ?? []);
}


// D:\vercel\mango-blog\src\lib\nextra-pages.ts
// src/lib/nextra-pages.ts
import { normalizePages } from "nextra/normalize-pages";
import { getPageMap } from "nextra/page-map";

export async function getDirectoryPages(route: string) {
  const { directories } = normalizePages({
    list: await getPageMap(route),
    route,
  });

  return directories;
}


